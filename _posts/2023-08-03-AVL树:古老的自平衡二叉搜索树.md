---
title: AVL树:古老的自平衡二叉搜索树
author: yuhang
date: 2023-08-03 07:05:00
categories: [日志, 算法, 二叉树]
tags: [算法, 二叉树]
---

之前的 [文章](https://peteryuhang.github.io/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%84%E9%A1%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/) 介绍了什么是二叉搜索树，以及它的各项操作。但在代码实现的时候，我们只是给出了最简单的算法，这之中很多点其实是可以被优化的。之中的最重要的一个点就是我们 **并没有去维持二叉搜索树的平衡**，因而在极端情况下，二叉搜索树会退化为链表一样的结构，从而导致搜索效率大幅下降，这也是我们很不希望看到的。今天所要讲的 AVL 树就是一种自我平衡的二叉搜索树，也是最早的自平衡二叉搜索树，后面的很多平衡二叉树都是基于它来改进的，比如我们所熟知的红黑树，以及 splay 树等等

## AVL 树的基本定义

AVL 树的定义，其实也就是平衡性的定义。关于平衡这个概念，存在多种定义，AVL 树的平衡定义非常直接，他要求 **每个节点的左右子树的高相差必须小于或等于 1**。这个定义其实算是比较严格的定义了，等到后面我们介绍 splay 树的时候，你就会发现平衡的定义又变了。

注意这里可能有人会对这个定义产生误解，认为整颗树上任意的两个叶子节点的深度[^1]相差也必须小于或等于 1。这个要求其实过于严厉了些，如果按照这个说法，那其实要求二叉树是一个完全二叉树[^2]或是满二叉树[^3]，这个要求在实际的应用中是难以达到的。AVL 的要求仅仅是每个节点的左右两颗子树的高相差 1 或 1 以内即可


## AVL 树的平衡性实现

之前的二叉搜索树的文章中，我们也提过，**树的结构的改变仅仅会发生在插入或删除操作后**，因为这些操作会增加或移除树上的某个节点，这就使某个或某些节点的左右子树的高的差从原来的 1 变为 2，因而和平衡性的定义不符。在这种情况下，我们就需要对树的平衡性进行调整。

如何调整？思路又是什么？从整体来看，思路是很直接的，树变得不平衡，那么首先就需要定位到不平衡的地方，然后将这个地方变为平衡。找的话很好找，甚至说可以不用找，我们只需要在插入或删除操作时进行同步勘查即可，如果发现平衡性被破坏，那么肯定是插入或删除的那个地方造成的。这里的难点其实在于如何将其变为平衡。

因为是二叉树，无非是那么几种情况，这里我们还是对所有的情况进行一一列举。

![插入发生在左子树的左边的节点](/assets/images/AVL%E6%83%85%E5%86%B51.png){: width="372" height="89" }

![插入发生在左子树的左边的节点](/assets/images/AVL%E6%83%85%E5%86%B51.png){: width="572" height="189" }





[^1]: https://peteryuhang.github.io/posts/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%84%E9%A1%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/
