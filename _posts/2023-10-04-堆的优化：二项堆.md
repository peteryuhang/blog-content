---
title: 堆的优化：二项堆
author: yuhang
date: 2023-10-04 07:17:00
math: true
categories: [日志, 算法, 堆]
tags: [算法, 堆]
---

## 普通堆存在的问题

在前面一篇 [文章](https://peteryuhang.github.io/posts/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C/) 中，我们介绍了堆，准确地说是二叉堆，这是最简单也是最基础的堆结构。除了获取最值，它的各项的时间复杂度均为 `O(logN)`。

普通堆有什么问题呢？难道这些操作还可以更快？先不急着思考如何优化这些操作，让我们来看一个案例。在实际场景中，我们经常需要做的一件事是合并两个数据集，比如将两个数组进行合并，将两个集合进行合并等等。堆也不例外，想象一下，如果我们要合并两个二叉堆，该如何做，时间复杂度又会是多少？

最直接也是最容易想到的方案是将一个堆中的元素挨个插入到另一个堆中，比如将元素少的堆中的元素插入到元素多的堆中，时间复杂度就是 `O( min(N1,N2) * log(max(N1,N2)) )`。

除了上面这种方式，我们也可以按照 [构建堆](https://peteryuhang.github.io/posts/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%93%8D%E4%BD%9C/#%E6%9E%84%E5%BB%BA%E5%A0%86) 的方法来进行堆的合并，这样整个操作时间复杂度就是 `O(N1 + N2)`。

不管用哪种合并方法，最后所产生的时间开销肯定是比堆的常规操作的 `O(logN)` 来得大。如果还想进一步优化的话，我们势必要对堆的结构做一些改变。

## 二项堆是什么

普通堆之所以会带来比较大的时间开销是因为所有的元素都在一个树上，特别是像合并这类操作，我们很难不去考虑整个树。那有没有可能我们可以把一个树拆成多个树？

二项堆就是基于这个思路来把整颗树拆分成了多颗树，所以二项堆是一个树的集合，就是 **森林**。那么具体是怎样的呢？

我们还是用数组来进行表示整个二项堆，数组中的每个元素就是一颗树的根节点。在此基础上，二项堆有如下规则：

1. 每个位子上的树的元素个数必须是 $ 2^{i} $，其中 `i` 是树在数组上的位置（起始是 0），比如数组第一个树的节点个数就必须是 1，第二个是 2，第三个是 4，以此类推
2. 当有元素进入到二项堆中，选择构建单节点树，将其放置在数组第一个位置，如果位置上有其他的树存在，就进行合并，然后选择放到第二个位置去，在第二位置重复之前的操作

相信单凭语言很难理解，我们还是来直接看一个从零构建堆的过程：

第一个元素插入，构建单节点的树，此时数组为空，直接放置到数组第一个位置：

![](/assets/images/%E4%BA%8C%E9%A1%B9%E5%A0%86_1.png){: width="372" height="89" }

第二个元素进来时，构建单节的树，此时第一个位置有树，我们将其合并，并将合并后的树放置到后面一个位置（这里我们展示的是最小堆，合并要保证最小元素必须在根节点，两树合并其实就是把其中一个树当作另一个树根节点的子树，无需其他操作）：

![](/assets/images/%E4%BA%8C%E9%A1%B9%E5%A0%86_2.png){: width="372" height="89" }

第三个元素插入，构建单节点的树，此时数组第一个位置为空，直接放置：

![](/assets/images/%E4%BA%8C%E9%A1%B9%E5%A0%86_3.png){: width="372" height="89" }

第四个元素插入，构建单节点的树，此时第一个位置有树，我们将其合并，放置到第二个位置的时候发现第二个位置也有树，继续合并，将合并后的树放置到第三个位置：

![](/assets/images/%E4%BA%8C%E9%A1%B9%E5%A0%86_4.png){: width="372" height="89" }

我们接着插入三个元素，操作完成后，堆的结构如下：

![](/assets/images/%E4%BA%8C%E9%A1%B9%E5%A0%86_5.png){: width="372" height="89" }