---
title: 堆的基本概念和操作
author: yuhang
date: 2023-09-29 22:45:00
categories: [日志, 算法, 堆]
tags: [算法, 堆]
---

堆（在 Java 中被称为优先队列）这个数据结构经常被用来获取给定数据的极值，并且能够在常数时间内达成。更重要的是，这个数据结构在排序、文件合并、以及一些筛选算法中都有广泛的应用。

## 基本概念与结构

这篇文章我们介绍的堆是 **二叉堆（Binary Heap）**，这是最简单也是最基础的堆结构。一般来说，没有特指，堆指的就是二叉堆。在此结构基础上进行调整，我们可以得到其他更为复杂的堆结构，比如二项堆（Binomial Heap）、左倾堆（Leftist Heap）、斜堆（Skew Heap）、d叉堆（d-Heap）等等。这些堆无非是针对特定的问题，由二叉堆衍生出来的数据结构。相信在理解了二叉堆后，我们有能力去学习这些堆的原理与实现。

二叉堆的其实就是二叉树，说的更准确些，是一个完全二叉树，如下图显示的：

![](/assets/images/%E5%A0%86.png){: width="372" height="89" }

那这么说，是不是意味着我们可以用操作二叉树的方法来操作堆？比如用树节点来表示堆节点，用树的各种遍历来遍历堆？这么做当然没错，但这里我们显然没有用到堆的特性————一个完全二叉树。**完全二叉树意味着树是被逐层填满的**，我们可以利用这个性质来寻找更为高效的表示方式。当我们把二叉树的每个节点从上到下，从左到右依次表上序号，上图就会显示成下图这样：

![](/assets/images/%E5%A0%86_2.png){: width="372" height="89" }

很容易发现，如果某个节点的标号是 `i`，那么它的左子节点的标号就是 `2 * i`，右子节点的标号就是 `2 * i + 1`，父节点的标号是 `i / 2`。知道了这些有什么用呢？想想看，既然通过下标的运算就可以准确无误地确定左右节点，还有父节点，那我们还有必要单独创建树节点来存放这些信息吗？显然没有必要，一个简单的数组就足够了：

![](/assets/images/%E5%A0%86%E7%9A%84%E8%A1%A8%E7%A4%BA.png){: width="372" height="89" }

数组带来的好处是空间的节省以及访问速度的提升，但是用数组来表示堆并没改变它原本的结构，那它又是如何做到在 `O(1)` 的时间获得极值的呢？

这里就不得不说堆中的元素的排列顺序了，把之前的图例用整形来表示，可以得到下面这个例子：

![](/assets/images/%E5%A0%86_3.png){: width="372" height="89" }

上面这个例子就是一个最小堆，我们可以观察到，**每个节点都比它的子节点小**，因而根节点存放的就是最小值，这样，我们无需任何遍历就可以在 `O(1)` 时间获得最小值。

当然，除了最小堆，还有最大堆，堆的结构限定我们没法同时获得最大值和最小值，除非维护两个堆。

## 基本操作

获取极值仅仅是堆的特殊查找操作。一个数据结构还必须要有一些基本的操作来保证该数据结构的可用性，对于堆来说也不例外。

### 插入

我们知道，堆其实是一个完全二叉树，它的节点是从上到下、从左到右逐层填充的，当有新元素进来，就很自然地被放在指定的位置。比如还是之前的例子，当有一个新的元素（14）进来，最开始我们可以得到如下的结构：

![](/assets/images/%E5%A0%86_insert.png){: width="372" height="89" }

你可能会说，这不对啊，前面我们提到堆的特性————每个节点都比它的子节点小/大————不就被破坏了吗？先不急，很多事情没办法一步到位。因为新插入的节点比它的父节点小，那么我们将其向上与父节点交换不就可以解决问题吗？只要是发现子节点比父节点小，我们就向上交换。上面这个例子，我们只需交换两次就可以维护堆的结构：

![](/assets/images/%E5%A0%86_insert_2.png){: width="372" height="89" }

<br>

![](/assets/images/%E5%A0%86_insert_3.png){: width="372" height="89" }

这个操作被称作 **percolate up**，可以理解是上提的意思。当然了，这个操作需要的时间复杂度显然就不是常数级别的了。这个时间复杂度和深度有关，因为是完全二叉树，最差就是 `O(logN)`，其中 `N` 是堆中总共的元素个数。

我们也可以相应地的到代码实现：

```java
public void insert(AnyType x) {
  if (currentSize == array.length - 1) {
    enlargeArray(array.length * 2 + 1);
  }

  int hole = ++currentSize;
  // percolate up
  for (array[0] = x; x.compareTo(array[hole/2]) < 0; hole /= 2) {
    array[hole] = array[hole / 2];
  }
  array[hole] = x;
}
```

### 删除最小值

有插入就有删除，但是在堆中，除了最值，我们很难去根据元素的值去对应堆中的节点（除非完整遍历）。因此，删除操作最直接的就是针对最值，也就是根节点。

删除意味着某个位置的元素被移除，但是在堆中，我们需要保证完全二叉树的结构，势必有其他的元素填补进来。那具体用哪个元素来填入？当然是最末尾的元素，我们还是拿之前的例子来说明，当根节点被删除后，我们用最末尾的元素进行填补：

![](/assets/images/%E5%A0%86_deleteMin.png){: width="372" height="89" }



在插入操作中，我们提到了 perlocate up 这个操作，类似地，我们也可将被删除节点的相对应的子节点上移
