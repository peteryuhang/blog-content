---
title: 堆的基本概念和操作
author: yuhang
date: 2023-09-29 22:45:00
categories: [日志, 算法, 堆]
tags: [算法, 堆]
---

堆（在 Java 中被称为优先队列）这个数据结构经常被用来获取给定数据的极值，并且能够在常数时间内达成。更重要的是，这个数据结构在排序、文件合并、以及一些筛选算法中都有广泛的应用。

## 基本概念与结构

这篇文章我们介绍的堆是 **二叉堆（Binary Heap）**，这是最简单也是最基础的堆结构。一般来说，没有特指，堆指的就是二叉堆。在此结构基础上进行调整，我们可以得到其他更为复杂的堆结构，比如二项堆（Binomial Heap）、左倾堆（Leftist Heap）、斜堆（Skew Heap）、d叉堆（d-Heap）等等。这些堆无非是针对特定的问题，由二叉堆衍生出来的数据结构。相信在理解了二叉堆后，我们有能力去学习这些堆的原理与实现。

二叉堆的其实就是二叉树，说的更准确些，是一个完全二叉树，如下图显示的：

![](/assets/images/%E5%A0%86.png){: width="372" height="89" }

那这么说，是不是意味着我们可以用操作二叉树的方法来操作堆？比如用树节点来表示堆节点，用树的各种遍历来遍历堆？这么做当然没错，但这里我们显然没有用到堆的特性————一个完全二叉树。**完全二叉树意味着树是被逐层填满的**，我们可以利用这个性质来寻找更为高效的表示方式。当我们把二叉树的每个节点从上到下，从左到右依次表上序号，上图就会显示成下图这样：

![](/assets/images/%E5%A0%86_2.png){: width="372" height="89" }

很容易发现，如果某个节点的标号是 `i`，那么它的左子节点的标号就是 `2 * i`，右子节点的标号就是 `2 * i + 1`，父节点的标号是 `i / 2`。知道了这些有什么用呢？想想看，既然通过下标的运算就可以准确无误地确定左右节点，还有父节点，那我们还有必要单独创建树节点来存放这些信息吗？显然没有必要，一个简单的数组就足够了：

![](/assets/images/%E5%A0%86%E7%9A%84%E8%A1%A8%E7%A4%BA.png){: width="372" height="89" }

数组带来的好处是空间的节省以及访问速度的提升，但是用数组来表示堆并没改变它原本的结构，那它又是如何做到在 `O(1)` 的时间获得极值的呢？

这里就不得不说堆中的元素的排列顺序了，把之前的图例用整形来表示，可以得到下面这个例子：

![](/assets/images/%E5%A0%86_3.png){: width="372" height="89" }

上面这个例子就是一个最小堆，我们可以观察到，**每个节点都比它的子节点小**，因而根节点存放的就是最小值，这样，我们无需任何遍历就可以在 `O(1)` 时间获得最小值。

当然，除了最小堆，还有最大堆，堆的结构限定我们没法同时获得最大值和最小值，除非维护两个堆。

## 基本操作

